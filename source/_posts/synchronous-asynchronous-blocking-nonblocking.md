title: 同步、异步与阻塞、非阻塞，UNIX I/O模型
date: 2015-04-21 23:28:43
tags: [synchronous, asynchronous, blocking, nonblocking, UNIX I/O]
categories: 服务端基础
---
 #### 1 同步与异步

同步和异步关注点是**消息通信机制** (synchronous communication/ asynchronous communication)，是一种编程模型。


   * 在同步模型下，由消息的处理者主动去等待消息的提供者。也就是说在发出一个“调用”后，在没有得到结果之前，该“调用”就不返回，但是一旦调用返回，就得到了返回值。

   * 在异步模型下，由消息提供者来通知处理者可以提供需要的结果（通知机制由异步实现模型来保证）。也就是说在“调用”在发出后就立即返回了，不需要等待结果，换句话说，调用者不会立刻得到结果。“被调用者”有结果提供时会主动通知调用者（一般通过状态更新(如.NET APM)或者回调函数(如Node.js,Tornado)的形式）。


举个通俗的例子：
> 你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，“你稍等，我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

#### 2 阻塞与非阻塞

阻塞和非阻塞关注的是**线程在等待调用结果（消息、结果）时的状态。**

   * 阻塞调用是指调用结果返回之前，当前线程做不了其他事情（***被挂起或者自旋***），调用线程只有在得到结果之后才会返回。

   * 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程（例如返回一个结果代理对象或者错误码）。

还是上面的例子
> 你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。

**在这里阻塞与非阻塞与是否同步异步无关**，跟老板通过什么方式回答你结果无关。


#### 3 UNIX I/O模型

在[《UNIX网络编程卷I》](http://book.douban.com/subject/1500149/)第6章中定义如下几种I/O模型：

   * 阻塞式I/O模型（blocking I/O）
   * 非阻塞式I/O模型（noblocking I/O）
   * I/O复用（mutiplexing， select/poll/epoll）
   * 信号驱动I/O（SIGIO)
   * 异步I/O（AIO）


通常一个输入包括两个过程：

   1. 等待数据准备好；
   2. 从内核向进程空间复制数据。


就socket的输入操作来说，第一步就是等待所有的数据从网络中达到。当所有分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从缓冲区复制到应用的进程缓冲区。

<!-- more -->

##### 3.1 阻塞式I/O模型：

{% asset_img blocking_model.png %}

理论上讲，默认情况下所有的socket都是阻塞的。如上图所示，我们把recvfrom函数视为系统调用，这样便于用于区分应用进程和内核。不论操作系统如何实现，一般该调用都会导致从应用进程空间切换到内核空间运行，一段时间后再切换回来。在阻塞式I/O模型中，进程调用recvfrom函数，其系统调用直到数据报全部到达并从内核复制到应用进程缓存区或者发生错误才返回。从调用recvfrom开始直到它返回的这段时间是被阻塞的。

##### 3.2 非阻塞式I/O模型

进程把一个socket设置成非阻塞是在通知内核，当所有的I/O操作非得把本进程投入睡眠才能完成时，不要把进程投入睡眠而是返回一个错误。

{% asset_img nonblocking_model.png %}

前三次调用recvfrom时没有数据可返回，因此内核转而激励返回一个EWOULDBLOCK错误。第四次调用时数据报已经准备好了，它才被复制进应用进程缓冲区，于是recvfrom成功返回。
当一个进程像这样对一个非阻塞描述符循环调用recvfrom时，我们称之为轮询（polling）。应用进程持续轮询内核，以查看某个操作是否就绪。这么做往往消耗大量的CPU时间，不过这种模型偶尔会遇到，通常是在提供某一种功能的系统中才有。

##### 3.3 I/O复用模型

有了I/O复用（I/O mutiplexing），我们就可以调用select或者poll，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的I/O系统调用上。

{% asset_img mutiplexing_model.png %}

我们阻塞于select调用，等待数据报socket变得可读。当select返回可读这个条件时，我们调用recvfrom把所有数据报复制到应用进程缓冲区。
从模型上看I/O复用相对于阻塞式I/O并没有什么优势，事实上还用了两个系统调用（select/recvfrom），I/O复用还稍有劣势。不过由于select能够同时等待多个描述符，这个功能还是很有用。

***与I/O复用密切相关的另一种I/O模型是在多线程中使用阻塞式I/O，这种模型与I/O复用极为相似，但是由于它没有使用select阻塞在多个文件描述符上，而是使用多个线程（每个描述符，一个线程），这样每个线程都可以自由地调用诸如recvfrom之类的阻塞式I/O系统调用。***


##### 3.4 信号驱动式I/O

让内核在描述符在就绪的时候发送SIGIO信号通知我们，我们称这种模型为信号驱动式I/O。

{% asset_img sig_model.png %}

无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间进程不被阻塞。直到调用recvfrom时，数据才从内核复制到应用进程空间缓冲区。


##### 3.5 异步I/O模型

异步I/O（asynchronous I/O）由POSIX规范定义。与POSIX规范的实时函数一致，一般地说这些函数的工作机制是：告知内核启动某个操作，并让内核在整个操作（包括从内核复制数据到我们应用的进程空间）完成后通知我们（***这个是不是与编程模型的异步定义看起来一样***）。

异步I/O模型与信号驱动式I/O的主要区别在于socket输入操作的第二步，在异步I/O模型中数据由内核复制到用户进程空间由模型完成后通知我们。换句话说，信号驱动I/O是由内核通知我们什么时候可以启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作什么时候完成。

{% asset_img sig_model.png %}


**上述阻塞式I/O模型、非阻塞式I/O模型、复用I/O模型、信号驱动式I/O，不同之处仅在在socket输入操作的第一步等待数据报完成就绪阶段，在阻塞式I/O模型、I/O复用模型中调用进程会被阻塞，非阻塞式I/O模型与信号驱动式I/O模型不会阻塞。第二步都是相同的，都需要调用recvfrom之类的系统调用等待数据从内核复制到应用进程空间。在异步I/O模型中这两个阶段都要处理，从而不同于其他4种模型。**


POSXI把这两个术语定义如下：
* 同步I/O操作（synchronouns I/O operation）导致请求进程阻塞，直到I/O操作完成；
* 异步I/O操作（asynchronous I/O operation）不导致请求进程阻塞。

{% asset_img compare_model.png %}

**根据上述定义，我们的前4种模型——阻塞式I/O模型、非阻塞式I/O模型、I/O复用模型和信号驱动模型都是同步I/O模型，因为其中真正的I/O操作（recvfrom）将阻塞进程。只有异步模型与POSIX定义的异步I/O相匹配。**

{% asset_img compare_model.png %}

#### 4 参考资料

1. 同步与异步，阻塞与非阻塞的内容及例子主要引用了知乎问题 [“怎样理解阻塞非阻塞与同步异步的区别”](http://www.zhihu.com/question/19732473) 中 **卢伊、陈硕** 的回答。

2. UNIX I/O模型参考引用[《UNIX网络编程：卷一》](http://book.douban.com/subject/1500149/)第六章。
